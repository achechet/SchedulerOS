; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\ciu98428f_api_base_nonvm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\ciu98428f_api_base_nonvm.d --cpu=SC000 --bi --apcs=interwork -O0 -I.\INC -I.\API -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Device\ARM\ARMSC000\Include --omf_browse=.\obj\ciu98428f_api_base_nonvm.crf API\CIU98428F_API_Base_NoNVM.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  HED_T0_SendNBytes PROC
;;;126    *************************************************/ 
;;;127    unsigned int HED_T0_SendNBytes (unsigned char * DataAddr , unsigned int DataLen)
000000  4602              MOV      r2,r0
;;;128    {
;;;129    	if(DataLen == 0) 
000002  2900              CMP      r1,#0
000004  d101              BNE      |L1.10|
;;;130    	{
;;;131    		return (2);
000006  2002              MOVS     r0,#2
                  |L1.8|
;;;132    	}
;;;133    
;;;134    	//wait for idle time
;;;135    	while(SCI_IS_BUSY); 
;;;136    
;;;137    	//set auto retry time = 3
;;;138    	CLEAR_SCI_AUTO_RETRY_LIMIT; 
;;;139    	SET_SCI_AUTO_RETRY_LIMIT(3);
;;;140    
;;;141    	while(DataLen--)
;;;142    	{
;;;143    		//write one byte to buffer a time
;;;144    		SCISBUF = (*DataAddr++);
;;;145    		while(SCI_DATA_IS_SENDING);
;;;146    
;;;147    		if(SCI_PARITY_IS_ERROR == 0 )
;;;148    		{
;;;149    			SCISSR = 0;							//clr SCI status
;;;150    		}
;;;151    		else
;;;152    		{
;;;153    			SCITXFCR = 0x01;					//clr trans FIFO control
;;;154    			while ((SCITXFCR & 0x01) == 0x01);
;;;155    			SCISSR = 0;							//clr SCI status
;;;156    			return (1);    	
;;;157    		}
;;;158    	}
;;;159    	return (0);
;;;160    }
000008  4770              BX       lr
                  |L1.10|
00000a  bf00              NOP                            ;135
                  |L1.12|
00000c  48d9              LDR      r0,|L1.884|
00000e  6880              LDR      r0,[r0,#8]            ;135
000010  2328              MOVS     r3,#0x28              ;135
000012  4218              TST      r0,r3                 ;135
000014  d1fa              BNE      |L1.12|
000016  48d7              LDR      r0,|L1.884|
000018  6840              LDR      r0,[r0,#4]            ;138
00001a  0880              LSRS     r0,r0,#2              ;138
00001c  0080              LSLS     r0,r0,#2              ;138
00001e  4bd5              LDR      r3,|L1.884|
000020  6058              STR      r0,[r3,#4]            ;138
000022  4618              MOV      r0,r3                 ;139
000024  6840              LDR      r0,[r0,#4]            ;139
000026  2301              MOVS     r3,#1                 ;139
000028  4318              ORRS     r0,r0,r3              ;139
00002a  4bd2              LDR      r3,|L1.884|
00002c  6058              STR      r0,[r3,#4]            ;139
00002e  e01f              B        |L1.112|
                  |L1.48|
000030  7810              LDRB     r0,[r2,#0]            ;144
000032  4bd0              LDR      r3,|L1.884|
000034  6018              STR      r0,[r3,#0]            ;144
000036  1c52              ADDS     r2,r2,#1              ;144
000038  bf00              NOP                            ;145
                  |L1.58|
00003a  48ce              LDR      r0,|L1.884|
00003c  6880              LDR      r0,[r0,#8]            ;145
00003e  2310              MOVS     r3,#0x10              ;145
000040  4218              TST      r0,r3                 ;145
000042  d0fa              BEQ      |L1.58|
000044  48cb              LDR      r0,|L1.884|
000046  6880              LDR      r0,[r0,#8]            ;147
000048  2302              MOVS     r3,#2                 ;147
00004a  4218              TST      r0,r3                 ;147
00004c  d103              BNE      |L1.86|
00004e  2000              MOVS     r0,#0                 ;149
000050  4bc8              LDR      r3,|L1.884|
000052  6098              STR      r0,[r3,#8]            ;149
000054  e00c              B        |L1.112|
                  |L1.86|
000056  2001              MOVS     r0,#1                 ;153
000058  4bc6              LDR      r3,|L1.884|
00005a  6118              STR      r0,[r3,#0x10]         ;153
00005c  bf00              NOP                            ;154
                  |L1.94|
00005e  48c5              LDR      r0,|L1.884|
000060  6900              LDR      r0,[r0,#0x10]         ;154
000062  07c0              LSLS     r0,r0,#31             ;154
000064  0fc0              LSRS     r0,r0,#31             ;154
000066  d1fa              BNE      |L1.94|
000068  4bc2              LDR      r3,|L1.884|
00006a  6098              STR      r0,[r3,#8]            ;155
00006c  2001              MOVS     r0,#1                 ;156
00006e  e7cb              B        |L1.8|
                  |L1.112|
000070  4608              MOV      r0,r1                 ;141
000072  1e49              SUBS     r1,r1,#1              ;141
000074  2800              CMP      r0,#0                 ;141
000076  d1db              BNE      |L1.48|
000078  bf00              NOP                            ;159
00007a  e7c5              B        |L1.8|
;;;161    /************************************************* 
                          ENDP

                  HED_T0_ReceiveNBytesRam PROC
;;;172    *************************************************/ 
;;;173    void HED_T0_ReceiveNBytesRam(unsigned char *DataAddr, unsigned int DataLen)
00007c  bf00              NOP      
                  |L1.126|
;;;174    {
;;;175    	while(SCI_IS_BUSY);
00007e  4abd              LDR      r2,|L1.884|
000080  6892              LDR      r2,[r2,#8]
000082  2328              MOVS     r3,#0x28
000084  421a              TST      r2,r3
000086  d1fa              BNE      |L1.126|
;;;176    
;;;177    	while(DataLen--)
000088  e009              B        |L1.158|
                  |L1.138|
;;;178    	{	 	      
;;;179    		//wait for data
;;;180    		while(SCIRXFCR_RX_IS_EMPTY);
00008a  bf00              NOP      
                  |L1.140|
00008c  4ab9              LDR      r2,|L1.884|
00008e  6952              LDR      r2,[r2,#0x14]
000090  2302              MOVS     r3,#2
000092  421a              TST      r2,r3
000094  d1fa              BNE      |L1.140|
;;;181    		(*DataAddr++) = (unsigned char)SCISBUF; 
000096  4ab7              LDR      r2,|L1.884|
000098  6812              LDR      r2,[r2,#0]
00009a  7002              STRB     r2,[r0,#0]
00009c  1c40              ADDS     r0,r0,#1
                  |L1.158|
00009e  460a              MOV      r2,r1                 ;177
0000a0  1e49              SUBS     r1,r1,#1              ;177
0000a2  2a00              CMP      r2,#0                 ;177
0000a4  d1f1              BNE      |L1.138|
;;;182    	}
;;;183    }
0000a6  4770              BX       lr
;;;184    
                          ENDP

                  HED_CRC16 PROC
;;;200    *************************************************/ 
;;;201    unsigned short HED_CRC16(unsigned short IV, unsigned int DataLen, unsigned char *DataBuf, unsigned char type)
0000a8  b5ff              PUSH     {r0-r7,lr}
;;;202    {
0000aa  b081              SUB      sp,sp,#4
;;;203    	unsigned int tmp_cnt = (unsigned int)DataBuf & 0x3; //distance to previous word border
0000ac  0793              LSLS     r3,r2,#30
0000ae  0f9b              LSRS     r3,r3,#30
;;;204    	unsigned int div4_quotient, div4_mod;   //
;;;205    
;;;206    	if(DataLen == 0)
0000b0  2900              CMP      r1,#0
0000b2  d102              BNE      |L1.186|
;;;207    	{
;;;208    		return IV;
0000b4  9801              LDR      r0,[sp,#4]
                  |L1.182|
;;;209    	}
;;;210    	
;;;211    	CRCIV = IV;
;;;212    	CRCCSR = ((type&0x3)<<1) | SET_BIT(CRCCSR_CRC_ST);
;;;213    
;;;214    	if (DataLen <= 0x07)
;;;215    	{
;;;216    		div4_quotient = 0;
;;;217    		div4_mod = DataLen;   
;;;218    	}
;;;219    	else
;;;220    	{
;;;221    		unsigned int curr_crccsr = CRCCSR;
;;;222    		if (tmp_cnt)
;;;223    		{
;;;224    			tmp_cnt = 0x4 - tmp_cnt;
;;;225    			DataLen -= tmp_cnt;
;;;226    			CHANGE_CRC_WIDTH_FROM_32_TO_8;   //CRCCSR[5:4] = 10 ->8
;;;227    			while (tmp_cnt--)
;;;228    			{
;;;229    				CRCDATA = *DataBuf++;
;;;230    			}
;;;231    		}
;;;232    		div4_quotient = DataLen >> 0x02; 
;;;233    		div4_mod = DataLen & 0x3;   //word numbers
;;;234    		CRCCSR = curr_crccsr;
;;;235    
;;;236    		if (div4_quotient)
;;;237    		{
;;;238    			unsigned int * tmp_databuf = (unsigned int *)DataBuf;
;;;239    			while (div4_quotient--)
;;;240    			{
;;;241    				CRCDATA = *(unsigned int *)tmp_databuf++;//4 bytes one time
;;;242    			}
;;;243    			DataBuf = (unsigned char *)tmp_databuf;
;;;244    		}
;;;245    	}
;;;246    
;;;247    	if (div4_mod)	
;;;248    	{
;;;249    		CHANGE_CRC_WIDTH_FROM_32_TO_8;   //CRCCSR[5:4] = 10 ->8
;;;250    		while (div4_mod--)
;;;251    		{
;;;252    			CRCDATA = *DataBuf++;
;;;253    		}
;;;254    
;;;255    	}
;;;256    
;;;257    	return (unsigned short)CRCDATA;
;;;258    }
0000b6  b005              ADD      sp,sp,#0x14
0000b8  bdf0              POP      {r4-r7,pc}
                  |L1.186|
0000ba  4eaf              LDR      r6,|L1.888|
0000bc  9801              LDR      r0,[sp,#4]            ;211
0000be  60b0              STR      r0,[r6,#8]            ;211
0000c0  9804              LDR      r0,[sp,#0x10]         ;212
0000c2  0780              LSLS     r0,r0,#30             ;212
0000c4  0f40              LSRS     r0,r0,#29             ;212
0000c6  1c40              ADDS     r0,r0,#1              ;212
0000c8  6030              STR      r0,[r6,#0]            ;212
0000ca  2907              CMP      r1,#7                 ;214
0000cc  d802              BHI      |L1.212|
0000ce  2400              MOVS     r4,#0                 ;216
0000d0  460d              MOV      r5,r1                 ;217
0000d2  e02a              B        |L1.298|
                  |L1.212|
0000d4  48a8              LDR      r0,|L1.888|
0000d6  6800              LDR      r0,[r0,#0]            ;221
0000d8  9000              STR      r0,[sp,#0]            ;221
0000da  2b00              CMP      r3,#0                 ;222
0000dc  d011              BEQ      |L1.258|
0000de  2004              MOVS     r0,#4                 ;224
0000e0  1ac3              SUBS     r3,r0,r3              ;224
0000e2  1ac9              SUBS     r1,r1,r3              ;225
0000e4  48a4              LDR      r0,|L1.888|
0000e6  6800              LDR      r0,[r0,#0]            ;226
0000e8  2620              MOVS     r6,#0x20              ;226
0000ea  4330              ORRS     r0,r0,r6              ;226
0000ec  4ea2              LDR      r6,|L1.888|
0000ee  6030              STR      r0,[r6,#0]            ;226
0000f0  e003              B        |L1.250|
                  |L1.242|
0000f2  7810              LDRB     r0,[r2,#0]            ;229
0000f4  4ea0              LDR      r6,|L1.888|
0000f6  6070              STR      r0,[r6,#4]            ;229
0000f8  1c52              ADDS     r2,r2,#1              ;229
                  |L1.250|
0000fa  4618              MOV      r0,r3                 ;227
0000fc  1e5b              SUBS     r3,r3,#1              ;227
0000fe  2800              CMP      r0,#0                 ;227
000100  d1f7              BNE      |L1.242|
                  |L1.258|
000102  088c              LSRS     r4,r1,#2              ;232
000104  078d              LSLS     r5,r1,#30             ;233
000106  0fad              LSRS     r5,r5,#30             ;233
000108  4e9b              LDR      r6,|L1.888|
00010a  9800              LDR      r0,[sp,#0]            ;234
00010c  6030              STR      r0,[r6,#0]            ;234
00010e  2c00              CMP      r4,#0                 ;236
000110  d00a              BEQ      |L1.296|
000112  4610              MOV      r0,r2                 ;238
000114  e002              B        |L1.284|
                  |L1.278|
000116  c840              LDM      r0!,{r6}              ;241
000118  4f97              LDR      r7,|L1.888|
00011a  607e              STR      r6,[r7,#4]            ;241
                  |L1.284|
00011c  4626              MOV      r6,r4                 ;239
00011e  1e64              SUBS     r4,r4,#1              ;239
000120  2e00              CMP      r6,#0                 ;239
000122  d1f8              BNE      |L1.278|
000124  4602              MOV      r2,r0                 ;243
000126  bf00              NOP                            ;244
                  |L1.296|
000128  bf00              NOP                            ;245
                  |L1.298|
00012a  2d00              CMP      r5,#0                 ;247
00012c  d00e              BEQ      |L1.332|
00012e  4892              LDR      r0,|L1.888|
000130  6800              LDR      r0,[r0,#0]            ;249
000132  2620              MOVS     r6,#0x20              ;249
000134  4330              ORRS     r0,r0,r6              ;249
000136  4e90              LDR      r6,|L1.888|
000138  6030              STR      r0,[r6,#0]            ;249
00013a  e003              B        |L1.324|
                  |L1.316|
00013c  7810              LDRB     r0,[r2,#0]            ;252
00013e  4e8e              LDR      r6,|L1.888|
000140  6070              STR      r0,[r6,#4]            ;252
000142  1c52              ADDS     r2,r2,#1              ;252
                  |L1.324|
000144  4628              MOV      r0,r5                 ;250
000146  1e6d              SUBS     r5,r5,#1              ;250
000148  2800              CMP      r0,#0                 ;250
00014a  d1f7              BNE      |L1.316|
                  |L1.332|
00014c  488a              LDR      r0,|L1.888|
00014e  6840              LDR      r0,[r0,#4]            ;257
000150  b280              UXTH     r0,r0                 ;257
000152  e7b0              B        |L1.182|
;;;259    
                          ENDP

                  HED_GetChipInfo PROC
;;;260    /* Serial Num */
;;;261    void HED_GetChipInfo(unsigned char *DataBuf, unsigned int FlashAddr, unsigned int DataLen)
000154  b510              PUSH     {r4,lr}
;;;262    {
;;;263    	while(DataLen--)
000156  e003              B        |L1.352|
                  |L1.344|
;;;264    	{
;;;265    		*DataBuf++ = *(unsigned char *)FlashAddr;
000158  780b              LDRB     r3,[r1,#0]
00015a  7003              STRB     r3,[r0,#0]
00015c  1c40              ADDS     r0,r0,#1
;;;266    		FlashAddr += 0x00000001;
00015e  1c49              ADDS     r1,r1,#1
                  |L1.352|
000160  4613              MOV      r3,r2                 ;263
000162  1e52              SUBS     r2,r2,#1              ;263
000164  2b00              CMP      r3,#0                 ;263
000166  d1f7              BNE      |L1.344|
;;;267    	}
;;;268    } 
000168  bd10              POP      {r4,pc}
;;;269    /* Chip ID */
                          ENDP

                  HED_GetChipId PROC
;;;278    *************************************************/ 
;;;279    void HED_GetChipId(unsigned char *ChipId)
00016a  b51c              PUSH     {r2-r4,lr}
;;;280    {
00016c  4604              MOV      r4,r0
;;;281        unsigned char die_YX_position;
;;;282        unsigned char test_month;
;;;283        
;;;284        HED_GetChipInfo(ChipId,  FACTORY_CODE_SADDR+0x09, 1);	//Test year
00016e  2201              MOVS     r2,#1
000170  4982              LDR      r1,|L1.892|
000172  4620              MOV      r0,r4
000174  f7fffffe          BL       HED_GetChipInfo
;;;285        
;;;286        /*get 2nd sequence number*/
;;;287        HED_GetChipInfo(&die_YX_position,  FACTORY_CODE_SADDR+0x17, 1);	//get die X/Y position on wafer
000178  2201              MOVS     r2,#1
00017a  4980              LDR      r1,|L1.892|
00017c  310e              ADDS     r1,r1,#0xe
00017e  a801              ADD      r0,sp,#4
000180  f7fffffe          BL       HED_GetChipInfo
;;;288        HED_GetChipInfo(&test_month,  FACTORY_CODE_SADDR+0x0A, 1);	//get test_month
000184  2201              MOVS     r2,#1
000186  497d              LDR      r1,|L1.892|
000188  1c49              ADDS     r1,r1,#1
00018a  4668              MOV      r0,sp
00018c  f7fffffe          BL       HED_GetChipInfo
;;;289        die_YX_position = ((die_YX_position & 0x10) << 3) | ((die_YX_position & 0x01) << 6);    
000190  4668              MOV      r0,sp
000192  7900              LDRB     r0,[r0,#4]
000194  2110              MOVS     r1,#0x10
000196  4008              ANDS     r0,r0,r1
000198  00c1              LSLS     r1,r0,#3
00019a  4668              MOV      r0,sp
00019c  7900              LDRB     r0,[r0,#4]
00019e  07c0              LSLS     r0,r0,#31
0001a0  0e40              LSRS     r0,r0,#25
0001a2  4301              ORRS     r1,r1,r0
0001a4  4668              MOV      r0,sp
0001a6  7101              STRB     r1,[r0,#4]
;;;290        test_month = (test_month >> 4)*10 + (test_month & 0x0F);
0001a8  7800              LDRB     r0,[r0,#0]
0001aa  1101              ASRS     r1,r0,#4
0001ac  200a              MOVS     r0,#0xa
0001ae  4341              MULS     r1,r0,r1
0001b0  4668              MOV      r0,sp
0001b2  7800              LDRB     r0,[r0,#0]
0001b4  0700              LSLS     r0,r0,#28
0001b6  0f00              LSRS     r0,r0,#28
0001b8  1808              ADDS     r0,r1,r0
0001ba  b2c1              UXTB     r1,r0
0001bc  4668              MOV      r0,sp
0001be  7001              STRB     r1,[r0,#0]
;;;291        test_month &= 0x3F;
0001c0  7800              LDRB     r0,[r0,#0]
0001c2  0681              LSLS     r1,r0,#26
0001c4  0e89              LSRS     r1,r1,#26
0001c6  4668              MOV      r0,sp
0001c8  7001              STRB     r1,[r0,#0]
;;;292        ChipId[1] = die_YX_position | test_month;
0001ca  7900              LDRB     r0,[r0,#4]
0001cc  4669              MOV      r1,sp
0001ce  7809              LDRB     r1,[r1,#0]
0001d0  4308              ORRS     r0,r0,r1
0001d2  7060              STRB     r0,[r4,#1]
;;;293        /*get 2nd sequence number*/
;;;294        
;;;295        HED_GetChipInfo(ChipId+2,  FACTORY_CODE_SADDR+0x1C, 1);	//lot number (highest byte)
0001d4  2201              MOVS     r2,#1
0001d6  4969              LDR      r1,|L1.892|
0001d8  3113              ADDS     r1,r1,#0x13
0001da  1ca0              ADDS     r0,r4,#2
0001dc  f7fffffe          BL       HED_GetChipInfo
;;;296        HED_GetChipInfo(ChipId+3,  FACTORY_CODE_SADDR+0x1D, 1);	//lot number (second byte)
0001e0  2201              MOVS     r2,#1
0001e2  4966              LDR      r1,|L1.892|
0001e4  3114              ADDS     r1,r1,#0x14
0001e6  1ce0              ADDS     r0,r4,#3
0001e8  f7fffffe          BL       HED_GetChipInfo
;;;297        HED_GetChipInfo(ChipId+4,  FACTORY_CODE_SADDR+0x1E, 1);	//lot number (third byte)
0001ec  2201              MOVS     r2,#1
0001ee  4963              LDR      r1,|L1.892|
0001f0  3115              ADDS     r1,r1,#0x15
0001f2  1d20              ADDS     r0,r4,#4
0001f4  f7fffffe          BL       HED_GetChipInfo
;;;298        HED_GetChipInfo(ChipId+5,  FACTORY_CODE_SADDR+0x1F, 1);	//lot number (fourth byte)
0001f8  2201              MOVS     r2,#1
0001fa  4960              LDR      r1,|L1.892|
0001fc  3116              ADDS     r1,r1,#0x16
0001fe  1d60              ADDS     r0,r4,#5
000200  f7fffffe          BL       HED_GetChipInfo
;;;299        HED_GetChipInfo(ChipId+6,  FACTORY_CODE_SADDR+0x0B, 1);	//lot number (fifth byte)
000204  2201              MOVS     r2,#1
000206  495d              LDR      r1,|L1.892|
000208  1c89              ADDS     r1,r1,#2
00020a  1da0              ADDS     r0,r4,#6
00020c  f7fffffe          BL       HED_GetChipInfo
;;;300        HED_GetChipInfo(ChipId+7,  FACTORY_CODE_SADDR+0x0C, 1);	//lot number (lowest byte)
000210  2201              MOVS     r2,#1
000212  495a              LDR      r1,|L1.892|
000214  1cc9              ADDS     r1,r1,#3
000216  1de0              ADDS     r0,r4,#7
000218  f7fffffe          BL       HED_GetChipInfo
;;;301        HED_GetChipInfo(ChipId+8,  FACTORY_CODE_SADDR+0x1A, 1);	//lot subsidiary number (high byte)
00021c  2201              MOVS     r2,#1
00021e  4957              LDR      r1,|L1.892|
000220  3111              ADDS     r1,r1,#0x11
000222  4620              MOV      r0,r4
000224  3008              ADDS     r0,r0,#8
000226  f7fffffe          BL       HED_GetChipInfo
;;;302        HED_GetChipInfo(ChipId+9,  FACTORY_CODE_SADDR+0x1B, 1);	//lot subsidiary number (low byte)
00022a  2201              MOVS     r2,#1
00022c  4953              LDR      r1,|L1.892|
00022e  3112              ADDS     r1,r1,#0x12
000230  4620              MOV      r0,r4
000232  3009              ADDS     r0,r0,#9
000234  f7fffffe          BL       HED_GetChipInfo
;;;303        HED_GetChipInfo(ChipId+10,  FACTORY_CODE_SADDR+0x0D, 1); //wafer number
000238  2201              MOVS     r2,#1
00023a  4950              LDR      r1,|L1.892|
00023c  1d09              ADDS     r1,r1,#4
00023e  4620              MOV      r0,r4
000240  300a              ADDS     r0,r0,#0xa
000242  f7fffffe          BL       HED_GetChipInfo
;;;304        HED_GetChipInfo(ChipId+11,  FACTORY_CODE_SADDR+0x0E, 1); //die X position on wafer
000246  2201              MOVS     r2,#1
000248  494c              LDR      r1,|L1.892|
00024a  1d49              ADDS     r1,r1,#5
00024c  4620              MOV      r0,r4
00024e  300b              ADDS     r0,r0,#0xb
000250  f7fffffe          BL       HED_GetChipInfo
;;;305        HED_GetChipInfo(ChipId+12,  FACTORY_CODE_SADDR+0x0F, 1); //die Y position on wafer
000254  2201              MOVS     r2,#1
000256  4949              LDR      r1,|L1.892|
000258  1d89              ADDS     r1,r1,#6
00025a  4620              MOV      r0,r4
00025c  300c              ADDS     r0,r0,#0xc
00025e  f7fffffe          BL       HED_GetChipInfo
;;;306    }
000262  bd1c              POP      {r2-r4,pc}
;;;307    
                          ENDP

                  HED_GetFactoryCode PROC
;;;317    *************************************************/ 
;;;318    void HED_GetFactoryCode(unsigned char *FactoryCode)
000264  b510              PUSH     {r4,lr}
;;;319    {
000266  4604              MOV      r4,r0
;;;320    	HED_GetChipInfo(FactoryCode, FACTORY_CODE_SADDR, 32);
000268  2220              MOVS     r2,#0x20
00026a  4944              LDR      r1,|L1.892|
00026c  3909              SUBS     r1,r1,#9
00026e  4620              MOV      r0,r4
000270  f7fffffe          BL       HED_GetChipInfo
;;;321    }
000274  bd10              POP      {r4,pc}
;;;322    
                          ENDP

                  HED_GetRandom PROC
;;;334    *************************************************/ 
;;;335    void HED_GetRandom(unsigned char *RandomData,unsigned int DataLen)
000276  b5f8              PUSH     {r3-r7,lr}
;;;336    {
;;;337    	unsigned int div4_quotient, div4_mod;
;;;338    	unsigned int *tmp_databuf;	
;;;339    	unsigned int bakSYSCLKEN;
;;;340    	unsigned int tmp_cnt = (unsigned int)RandomData & 0x3; //distance to previous word border
000278  0785              LSLS     r5,r0,#30
00027a  0fad              LSRS     r5,r5,#30
;;;341    
;;;342    	bakSYSCLKEN = SYSCLKEN;    
00027c  4e40              LDR      r6,|L1.896|
00027e  6836              LDR      r6,[r6,#0]
000280  9600              STR      r6,[sp,#0]
;;;343    	SYSCLKEN |= (1<<8); 
000282  4e3f              LDR      r6,|L1.896|
000284  6836              LDR      r6,[r6,#0]
000286  27ff              MOVS     r7,#0xff
000288  3701              ADDS     r7,#1
00028a  433e              ORRS     r6,r6,r7
00028c  4f3c              LDR      r7,|L1.896|
00028e  603e              STR      r6,[r7,#0]
;;;344    	
;;;345    	if(RANDOM_NUM_IS_TIMEOUT)
000290  4e3c              LDR      r6,|L1.900|
000292  6b36              LDR      r6,[r6,#0x30]
000294  2702              MOVS     r7,#2
000296  423e              TST      r6,r7
000298  d004              BEQ      |L1.676|
;;;346    	{
;;;347    		CLEAR_REG_BIT(RNG1STR,RNG1STR_TIMEOUT);
00029a  4e3a              LDR      r6,|L1.900|
00029c  6b36              LDR      r6,[r6,#0x30]
00029e  43be              BICS     r6,r6,r7
0002a0  4f38              LDR      r7,|L1.900|
0002a2  633e              STR      r6,[r7,#0x30]
                  |L1.676|
;;;348    	}
;;;349    
;;;350    	if (DataLen <= 0x07)
0002a4  2907              CMP      r1,#7
0002a6  d802              BHI      |L1.686|
;;;351    	{
;;;352    		div4_quotient = 0;
0002a8  2200              MOVS     r2,#0
;;;353    		div4_mod = DataLen;
0002aa  460b              MOV      r3,r1
0002ac  e028              B        |L1.768|
                  |L1.686|
;;;354    	}
;;;355    	else
;;;356    	{
;;;357    		if (tmp_cnt)
0002ae  2d00              CMP      r5,#0
0002b0  d011              BEQ      |L1.726|
;;;358    		{
;;;359    			tmp_cnt = 0x4 - tmp_cnt;
0002b2  2604              MOVS     r6,#4
0002b4  1b75              SUBS     r5,r6,r5
;;;360    			DataLen -= tmp_cnt;
0002b6  1b49              SUBS     r1,r1,r5
;;;361    			while (tmp_cnt--)
0002b8  e009              B        |L1.718|
                  |L1.698|
;;;362    			{
;;;363    				while(RANDOM_NUM_IS_NOT_OK);
0002ba  bf00              NOP      
                  |L1.700|
0002bc  4e31              LDR      r6,|L1.900|
0002be  6b36              LDR      r6,[r6,#0x30]
0002c0  07f6              LSLS     r6,r6,#31
0002c2  0ff6              LSRS     r6,r6,#31
0002c4  d0fa              BEQ      |L1.700|
;;;364    				*(RandomData++) = (unsigned char)RNG1OUT;
0002c6  4e2f              LDR      r6,|L1.900|
0002c8  6b76              LDR      r6,[r6,#0x34]
0002ca  7006              STRB     r6,[r0,#0]
0002cc  1c40              ADDS     r0,r0,#1
                  |L1.718|
0002ce  462e              MOV      r6,r5                 ;361
0002d0  1e6d              SUBS     r5,r5,#1              ;361
0002d2  2e00              CMP      r6,#0                 ;361
0002d4  d1f1              BNE      |L1.698|
                  |L1.726|
;;;365    			}
;;;366    		}
;;;367    		div4_quotient = DataLen >> 0x02; 
0002d6  088a              LSRS     r2,r1,#2
;;;368    		div4_mod = DataLen & 0x3;//word numbers
0002d8  078b              LSLS     r3,r1,#30
0002da  0f9b              LSRS     r3,r3,#30
;;;369    
;;;370    		if (div4_quotient)
0002dc  2a00              CMP      r2,#0
0002de  d00f              BEQ      |L1.768|
;;;371    		{
;;;372    			tmp_databuf = (unsigned int *)RandomData;
0002e0  4604              MOV      r4,r0
;;;373    			while (div4_quotient--)
0002e2  e008              B        |L1.758|
                  |L1.740|
;;;374    			{
;;;375    				while(RANDOM_NUM_IS_NOT_OK);
0002e4  bf00              NOP      
                  |L1.742|
0002e6  4e27              LDR      r6,|L1.900|
0002e8  6b36              LDR      r6,[r6,#0x30]
0002ea  07f6              LSLS     r6,r6,#31
0002ec  0ff6              LSRS     r6,r6,#31
0002ee  d0fa              BEQ      |L1.742|
;;;376    				*(tmp_databuf++) = RNG1OUT;
0002f0  4e24              LDR      r6,|L1.900|
0002f2  6b76              LDR      r6,[r6,#0x34]
0002f4  c440              STM      r4!,{r6}
                  |L1.758|
0002f6  4616              MOV      r6,r2                 ;373
0002f8  1e52              SUBS     r2,r2,#1              ;373
0002fa  2e00              CMP      r6,#0                 ;373
0002fc  d1f2              BNE      |L1.740|
;;;377    			}
;;;378    			RandomData = (unsigned char *)tmp_databuf;
0002fe  4620              MOV      r0,r4
                  |L1.768|
;;;379    		}
;;;380    	}
;;;381    
;;;382    	if (div4_mod)	
000300  2b00              CMP      r3,#0
000302  d00e              BEQ      |L1.802|
;;;383    	{
;;;384    		while (div4_mod--)
000304  e009              B        |L1.794|
                  |L1.774|
;;;385    		{
;;;386    			while(RANDOM_NUM_IS_NOT_OK);
000306  bf00              NOP      
                  |L1.776|
000308  4e1e              LDR      r6,|L1.900|
00030a  6b36              LDR      r6,[r6,#0x30]
00030c  07f6              LSLS     r6,r6,#31
00030e  0ff6              LSRS     r6,r6,#31
000310  d0fa              BEQ      |L1.776|
;;;387    			*(RandomData++) = (unsigned char)RNG1OUT; 
000312  4e1c              LDR      r6,|L1.900|
000314  6b76              LDR      r6,[r6,#0x34]
000316  7006              STRB     r6,[r0,#0]
000318  1c40              ADDS     r0,r0,#1
                  |L1.794|
00031a  461e              MOV      r6,r3                 ;384
00031c  1e5b              SUBS     r3,r3,#1              ;384
00031e  2e00              CMP      r6,#0                 ;384
000320  d1f1              BNE      |L1.774|
                  |L1.802|
;;;388    		}
;;;389    	}
;;;390    	SYSCLKCLR = (~bakSYSCLKEN);
000322  9e00              LDR      r6,[sp,#0]
000324  43f6              MVNS     r6,r6
000326  4f16              LDR      r7,|L1.896|
000328  607e              STR      r6,[r7,#4]
;;;391    }
00032a  bdf8              POP      {r3-r7,pc}
;;;392    
                          ENDP

                  HED_SetToStandby PROC
;;;429    *************************************************/ 
;;;430    void HED_SetToStandby(void)
00032c  4914              LDR      r1,|L1.896|
;;;431    {
;;;432    	unsigned int clkBak;
;;;433    	
;;;434        /* 1. change clock to 7.5MHz */
;;;435    	clkBak = SYSCLKCFG;
00032e  6888              LDR      r0,[r1,#8]
;;;436    	if((clkBak & 0x70) == (0x30))
000330  2170              MOVS     r1,#0x70
000332  4001              ANDS     r1,r1,r0
000334  2930              CMP      r1,#0x30
000336  d102              BNE      |L1.830|
;;;437    	{	
;;;438    		SYSCLKCFG = (0x04 << 4);	//cpu = 15MHz
000338  2140              MOVS     r1,#0x40
00033a  4a11              LDR      r2,|L1.896|
00033c  6091              STR      r1,[r2,#8]
                  |L1.830|
;;;439    	}
;;;440    	SYSCLKCFG = (0x05 << 4);	//cpu = 7.5MHz
00033e  2150              MOVS     r1,#0x50
000340  4a0f              LDR      r2,|L1.896|
000342  6091              STR      r1,[r2,#8]
;;;441    	
;;;442    	/* 2. entry standby */
;;;443    	if(STDBY_IS_VALID)
000344  490b              LDR      r1,|L1.884|
000346  6889              LDR      r1,[r1,#8]
000348  2208              MOVS     r2,#8
00034a  4211              TST      r1,r2
00034c  d107              BNE      |L1.862|
00034e  4909              LDR      r1,|L1.884|
000350  6949              LDR      r1,[r1,#0x14]
000352  2202              MOVS     r2,#2
000354  4211              TST      r1,r2
000356  d002              BEQ      |L1.862|
;;;444        {
;;;445    		__sev();	//set event reg
000358  bf40              SEV      
;;;446    		__wfe();	//clr event reg	
00035a  bf20              WFE      
;;;447    		__wfe();	//set standby
00035c  bf20              WFE      
                  |L1.862|
;;;448        }
;;;449    	
;;;450    	/* 3. retore clock config */
;;;451    	if((clkBak & 0x70) == (0x30))
00035e  2170              MOVS     r1,#0x70
000360  4001              ANDS     r1,r1,r0
000362  2930              CMP      r1,#0x30
000364  d102              BNE      |L1.876|
;;;452    	{	
;;;453    		SYSCLKCFG = (0x04 << 4);	//cpu = 15MHz
000366  2140              MOVS     r1,#0x40
000368  4a05              LDR      r2,|L1.896|
00036a  6091              STR      r1,[r2,#8]
                  |L1.876|
;;;454    	}
;;;455    	SYSCLKCFG = clkBak;		
00036c  4904              LDR      r1,|L1.896|
00036e  6088              STR      r0,[r1,#8]
;;;456    }
000370  4770              BX       lr
;;;457    
                          ENDP

000372  0000              DCW      0x0000
                  |L1.884|
                          DCD      0x40001000
                  |L1.888|
                          DCD      0x50005000
                  |L1.892|
                          DCD      0x1ffffe09
                  |L1.896|
                          DCD      0x50007200
                  |L1.900|
                          DCD      0x40002800

;*** Start embedded assembler ***

#line 1 "API\\CIU98428F_API_Base_NoNVM.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |delay|
#line 412
|delay| PROC
#line 413

loopStart
 SUBS r0,r0,#1
 BCS loopStart
 BX lr
	ENDP

;*** End   embedded assembler ***
